;
; Copyright (c) 2020 Raspberry Pi (Trading) Ltd.
;
; SPDX-License-Identifier: BSD-3-Clause
;
.pio_version 0 // only requires PIO version 0

.program i2c_bus_analyzer

;pin 0 is SDA (GPIO 0, physical pin 1)
;pin 1 is SCL (GPIO 1, physical pin 2)

.wrap_target
wait_for_start:
    wait 0 pin 0                ;wait for logic 0 on pin 0 (SDA) which is the start bit
    mov x, pins                 ;move pin values to x
    set y, 0b1010               ;make sure SDA is low with SCL high, remember that we have GPIO 0 connected to GPIO2, GPIO 1 connected to GPIO 3
    jmp x!=y wait_for_start
    mov isr, ~y                 ;set the input shift register to something recognizable 0xfffffff5
    push                        ;push the input shift register to the Rx FIFO so the system can read it, clears the register, autopush doesn't work here



    wait 0 pin 1


    
wait_for_byte:
    set x, 8                    ;loop 9 times
wait_for_new_bit:
    wait 1 pin 1 [10]           ;SCL goes high
    in pins, 1                  ;grab SDA
    wait 0 pin 1
    jmp x-- wait_for_new_bit
    push                        ;push the 9 bits




    wait 1 pin 1
    in pins, 1                  ;grab SDA in case it is another byte transfer
    jmp pin wait_for_byte_or_start



    ;it's 0b10 so wait for new byte or stop
wait_for_byte_or_stop:
    ;if it's 0b11 then go to stop
    jmp pin stop

    ;if SCL is low, then it's a byte, and we already grabbed the first bit
    set x, 7
    mov y, pins
    jmp !y wait_for_new_bit

    jmp wait_for_byte_or_stop



    ;it's 0b11 so wait for new byte or start
wait_for_byte_or_start:
    ;if it's 0b01 then it's a byte
    mov x, pins                 ;move pin values to x
    set y, 0b0101
    jmp x!=y check_for_start
    set x, 7
    jmp wait_for_new_bit

    ;if it's 0b10 it's a start
check_for_start:
    set y, 0b1010
    jmp x!= y wait_for_byte_or_start
    jmp wait_for_start



stop:
    mov isr, ~x                 ;TODO: will x always be known??
    push

.wrap
